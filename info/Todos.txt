
General
	- Describe the coding case

-- -------------------------------------------------------------------------------------------------
-- Powerups
New
	- Add shield 4 that is charge based
	- Negative that activates current powerup in the vehicle inv immediatly
	- Add funny sounds to negatives

-- -------------------------------------------------------------------------------------------------
-- Libs
PowerupExtender
	- Add hasTraitButNot(target_id, has, butnot) variants for multi targets, hastraits and butnottraits

PowerupsLib
	- Delay target_info and target_hit exec to simulate beammp sync behaviour (would make powerup dev easier, as were already going to work with a behaviour that is otherwise only going to be true in multiplayer scenarios)
	- Auto remove undefined Traits
	- make "respect_traits" var necessary for trait call sync
	- Implement a "default" set, that only contains powerup defs. Is used when a group defines powerups but doesnt include any or all powerups
	- TraitBounds
		Powerups that handle other powerups traits cannot give the other powerups a "reason" as of why they handled the trait. Atleast over no safe way that can be universaly understood by any powerup that implements the trait. For this case trait bounds should be defined.
		
		Extender.callTrait(target_id, Trait.Consuming, TraitBounds.Consuming.Collision, origin_id)
		
		or
		
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Collision, origin_id)
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Impact, origin_id)
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Bullet, origin_id)
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Rocket, origin_id)
		
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Small, origin_id)
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Medium, origin_id)
		Extender.callTrait(target_id, Trait.Consuming, Consuming.Big, origin_id)
	
	- TraitResponses
		Eg. when a shield can break but doesnt want the attack to succeed but only the shield to immediatly break.
	
	- A render quo outside of location and vehicle ownerships
		If a powerup where to fire a bullet it could give up ownership, to free the vehicle slot, but still be rendered.
		
		Note
		Once the ownership is removed the server wont have a clue who owns it and this way is eligible to allow its targeting. That needs to be kept in mind.
		
	- Refactor the "targets" to "targets_info"
		Because a powerup doesnt always only target targets, as in target vehicles, but can also just have a projectile origin, direction and velocity. This info is synced to other clients. Or in other words simply make targets -> target_info
			
	- Implement two new defition variables to the active powerups
		- "max_length"
			Since the server never executes any powerup or active powerup related calls it cant tell when a power up ended. Yes a client could tell it when, but the server should have the last say.
		
		- "targets_info_describtor"
			Necessary for the server to verify incoming "targets_info" for their correct data type structure and types. Since this info is synced to other clients it needs to be verified.
	
	- Add location powerup rotation. Where if a location owns a powerup for X time then swap it out
		This could be defined by groups
	
	- For more variety in traffic "combat", a routine could run that checks if anyone is close to a traffic car and if so run a chance on whichs success it would grant a random powerup.
		This could go further by adding a new var into the group definitions where groups can implement logic that decides if this powerup should be chosen.
	
	- Add "type" to group definitions that describes the kind of powerup. This would be used for location definitions.
		Type.Offensive
		Type.Defensive
		Type.Negative
		Type.Charge
		Type.Utility
		Type.Handicapping
		Type.Undefined

SetsLib
	- Add setting for Sets to only exec triggers if vehicle is own (mp)
	- (oversight) revert() doesnt revert ghosting or the reset blocker
	- Add possibility to stack triggers. Where the next trigger in the set is enlisted after the previous was fully executed

TimedTriggers
	- VE to GE calls
	- Build a VE receiver that can take and deserialize args

ForceField
	- Must account for differently sized vehicles
	- Marker updates are not fluid! even hooking into onPreRender and disabling the update limit doesnt help it :/

MathUtil
	- MathUtil needs method to check if a from_vec to to_vec goes through terrain or other statics

